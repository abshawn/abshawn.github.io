<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://abshawn.github.io</id>
    <title>My Home</title>
    <updated>2020-01-13T09:42:16.766Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://abshawn.github.io"/>
    <link rel="self" href="https://abshawn.github.io/atom.xml"/>
    <subtitle>记录我的技术博客之路</subtitle>
    <logo>https://abshawn.github.io/images/avatar.png</logo>
    <icon>https://abshawn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, My Home</rights>
    <entry>
        <title type="html"><![CDATA[JAVA消息队列]]></title>
        <id>https://abshawn.github.io/post/java-xiao-xi-dui-lie</id>
        <link href="https://abshawn.github.io/post/java-xiao-xi-dui-lie">
        </link>
        <updated>2019-12-31T09:43:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>1</p>
</blockquote>
<p>近期公司项目中，听同事提起MQ、JMS，因为之前没有使用过不太了解，所以抽出半天时间学习下，了解下相关概念、功能及其用途。便于再次与人沟通时可以言之有物，后续工作中遇到了，可立马上手，提高工作效率。</p>
<h3 id="学习过程分为三个步骤">学习过程分为三个步骤：###</h3>
<ul>
<li>1  查找资料</li>
<li>2  实验实践</li>
<li>3  归纳总结</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2199827-04f33bdc2f8e00d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学习思路.jpg"></p>
<blockquote>
<p>2</p>
</blockquote>
<p>###查找资料###
推荐两篇博客，内容不错。</p>
<ul>
<li>1  <a href="http://www.cnblogs.com/chenpi/p/5559349.html">JMS(Java消息服务)入门教程</a>     ，比较适合了解基本知识，包括概念、分类、用途及其原理。</li>
<li>2 <a href="http://blog.sina.com.cn/s/blog_6166d8170100h0ty.html">消息队列MQ技术的介绍和原理</a>，介绍了消息队列MQ的基本知识点。
此处不再对技术内容进行复制粘贴，仅提供学习思路。首先用what、how、why提出自己心中感兴趣的几个问题，然后在到资料中找出想要的答案。例如：什么是Java消息服务？MQ? 为什么要有消息服务？优点是什么？消息服务是如何实现的？
JSM <em>Java Message Service</em>， MQ <em>Message Queue</em></li>
</ul>
<blockquote>
<p>3</p>
</blockquote>
<p>####实验####
通过上面的快速阅读和详细阅读之后，已经在概念上了解了，下面通过一个实验对概念和原理进行深入的理解，了解其用途及其适用范围。</p>
<ul>
<li>1  环境介绍
apache-tomcat-7.0.61、apache-activemq-5.6.0、eclipse neon、jdk 1.8.0 ；</li>
<li>2 实验代码工程链接地址
https://github.com/abshawn/JMSProject  ，可以从此处下载代码，在本地部署查看效果。</li>
<li>3 实验效果截图
通过activemq可以监控到消息队列的内容。
<img src="http://upload-images.jianshu.io/upload_images/2199827-a477301f88f244c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActiveMQ.jpg"></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2199827-882bc8be911b30f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息生产者.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2199827-e9d970824185b7c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息消费者.jpg"></p>
<blockquote>
<p>4</p>
</blockquote>
<p>###归纳总结###
** JMS “ 一个中心，两种模式，三步实现”**</p>
<ul>
<li>1 以 消息服务器为中心
消息生产者 通过客户端发消息给消息服务器；  消息消费者通过消息服务器接收消息；</li>
<li>2 两种消息发送模型
两种消息发送模型规范：点对点、发布订阅 ；</li>
<li>3 实现方法分为三步
3.1、 统一消息服务器，建立连接Connections ；
3.2 、通过连接建立队列会话session；
3.3 、准备就绪后，执行 生产者 发消息和消费者 接消息（异步）。
 
**优点     ** 解耦合、异步</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[npm常用命令使用指南]]></title>
        <id>https://abshawn.github.io/post/npm-chang-yong-ming-ling-shi-yong-zhi-nan</id>
        <link href="https://abshawn.github.io/post/npm-chang-yong-ming-ling-shi-yong-zhi-nan">
        </link>
        <updated>2019-07-08T11:17:38.000Z</updated>
        <summary type="html"><![CDATA[<p>总结自己常用的npm命令；</p>
]]></summary>
        <content type="html"><![CDATA[<p>总结自己常用的npm命令；</p>
<!-- more -->
<p>查看已安装的全局的包
npm list -g --depth 0</p>
<p>安装webpack
npm install webpack -g  | npm install  -g webpack</p>
<p>卸载webpack
npm uninstall webpack -g  | npm uninstall  -g webpack
卸载后，重新打开终端，输入查看已安装包命令即可</p>
<p>查看mac本的全局安装包和当前文件夹下的安装包：</p>
<p>ZBMAC-C02VX3K0H:~ zhangnan12$ which npm
/usr/local/bin/npm</p>
<p>sudo npm install -g nornj-cli
全局包安装在   /usr/local/lib  下面的 node_modules
sudo npm uninstall -g nornj-cli</p>
<p>ZBMAC-C02VX3K0H:~ zhangnan12$ npm ls -g --depth 0
/usr/local/lib
├── @vue/cli@3.9.2
├── asar@0.14.3
├── cc-cli@1.0.13
├── create-react-app@2.1.3
├── es-checker@1.4.1
├── install@0.12.2
├── n@4.1.0
├── nornj-cli@0.4.1
├── npm@6.10.0
└── webpack@4.35.2</p>
<p>ZBMAC-C02VX3K0H:~ zhangnan12$ npm ls  --depth 0
/Users/zhangnan12
├── @babel/core@7.3.4
└── list@2.0.18</p>
<ol start="2">
<li>全局包 安装在 /usr/local/lib  下面的 node_modules下
该文件夹的权限是 admin ，所以安装的时候总是提示 “errno -13”
ZBMAC-C02VX3K0H:~ zhangnan12$ npm i -g npm
npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules/npm
npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules
npm ERR! path /usr/local/lib/node_modules/npm
npm ERR! code EACCES
npm ERR! errno -13
npm ERR! syscall access
npm ERR! Error: EACCES: permission denied, access '/usr/local/lib/node_modules/npm'
npm ERR!  { [Error: EACCES: permission denied, access '/usr/local/lib/node_modules/npm']
npm ERR!   stack:
npm ERR!    'Error: EACCES: permission denied, access '/usr/local/lib/node_modules/npm'',
npm ERR!   errno: -13,
npm ERR!   code: 'EACCES',
npm ERR!   syscall: 'access',
npm ERR!   path: '/usr/local/lib/node_modules/npm' }
npm ERR!
npm ERR! The operation was rejected by your operating system.
npm ERR! It is likely you do not have the permissions to access this file as the current user
npm ERR!
npm ERR! If you believe this might be a permissions issue, please double-check the
npm ERR! permissions of the file and its containing directories, or try running
npm ERR! the command again as root/Administrator (though this is not recommended).</li>
</ol>
<p>npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/zhangnan12/.npm/_logs/2019-07-08T11_34_08_170Z-debug.log</p>
<p>解决方法：
将 /usr/local/lib  下面的 node_modules下，定义在 有权限的  /user/zhangnan/lib 下的node_modules
就方便了，后续安装的时候不用 sudo</p>
<p>创建全局的npm包安装路径
.npm-global 是隐藏文件夹   lib是显性文件夹 ，通过shift+command+.来 切换隐藏和显示
mkdir ~/.npm-global | 或者 mkdir  ~/lib</p>
<p>配置npm使用新的路径</p>
<p>npm config set prefix '~/.npm-global'</p>
<p>打开或者新建～/.profile文件并添加如下行</p>
<p>export PATH=~/.npm-global/bin:$PATH</p>
<p>更新刚才添加的环境变量</p>
<p>source ~/.profile</p>
<p>测试一下ok啦</p>
<p>npm install -g brower-sync</p>
<hr>
<p>3)修改全局npm包的路径</p>
<p>ZBMAC-C02VX3K0H:~ zhangnan12$ ls -ltra|grep .npm
drwxr-xr-x    8 zhangnan12  360BUYAD\Domain Users       256  1 28 10:46 .npm
-rw-------    1 zhangnan12  360BUYAD\Domain Users        63  7  9 09:49 .npmrc</p>
<p>.npmrc 文件是存在 npm config 命令的内容的；</p>
<pre><code>ZBMAC-C02VX3K0H:~ zhangnan12$ npm config list
</code></pre>
<p>; cli configs
metrics-registry = &quot;https://registry.npm.taobao.org/&quot;
scope = &quot;&quot;
user-agent = &quot;npm/6.10.0 node/v10.15.0 darwin x64&quot;</p>
<p>; userconfig /Users/zhangnan12/.npmrc
prefix = &quot;/Users/zhangnan12/.npm-global&quot;
registry = &quot;https://registry.npm.taobao.org/&quot;</p>
<p>; node bin location = /usr/local/bin/node
; cwd = /Users/zhangnan12
; HOME = /Users/zhangnan12
; &quot;npm config ls -l&quot; to show all defaults.</p>
<p>ZBMAC-C02VX3K0H:~ zhangnan12$ cat .npmrc
registry=https://registry.npm.taobao.org/
prefix=~/.npm-global</p>
<p>这个命令是修改全局npm安装包的存储本地的路径的；
npm config set prefix '~/lib'</p>
<p>修改路径后，添加到mac环境变量中进行生效 , $PATH存放在如下隐藏文件中。
.bash_profile</p>
<p>---查看 存放的地方， 在NPM_HOME路径下的  node_modules中。
ZBMAC-C02VX3K0H:~ zhangnan12$ npm root
/Users/zhangnan12/node_modules
ZBMAC-C02VX3K0H:~ zhangnan12$ npm root -g
/Users/zhangnan12/.npm-global/lib/node_modules</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何学习研究新的东西]]></title>
        <id>https://abshawn.github.io/post/ru-he-xue-xi-yan-jiu-xin-de-dong-xi</id>
        <link href="https://abshawn.github.io/post/ru-he-xue-xi-yan-jiu-xin-de-dong-xi">
        </link>
        <updated>2019-07-05T06:54:19.000Z</updated>
        <summary type="html"><![CDATA[<p>学习之道：渐进式的学习方法，引入新领域的东西与原来的知识进行关联，进而产生创新的知识点
学习之术：刘澜老师-去学习、成甲老师-好好学习等</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习之道：渐进式的学习方法，引入新领域的东西与原来的知识进行关联，进而产生创新的知识点
学习之术：刘澜老师-去学习、成甲老师-好好学习等</p>
<!-- more --> 
<p>承认的带问题或项目的学习思路
1、目标 ； 2、发散；3、聚焦；4、应用</p>
<p><img src="http://assets.processon.com/chart_image/5d1ef778e4b0aad4c92696bd.png" alt="processon 网络思维导图"></p>
<p>思维导图可以应用在发散过程中，自己学习过程中的问题，就是发散过度后产生聚焦忧虑症，觉得时间不够用在发散过程中浪费了很多时间。</p>
<p>聚焦可以着重专研，实际解决1和2过程中了解到的最关键的技术，为了完成4；</p>
<p>回顾2和3的过程，继续差缺补漏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建前端脚手架（2）-前端知识点]]></title>
        <id>https://abshawn.github.io/post/gou-jian-qian-duan-jiao-shou-jia-2-qian-duan-zhi-shi-dian</id>
        <link href="https://abshawn.github.io/post/gou-jian-qian-duan-jiao-shou-jia-2-qian-duan-zhi-shi-dian">
        </link>
        <updated>2019-07-04T11:26:19.000Z</updated>
        <summary type="html"><![CDATA[<p>node，npm，npx</p>
]]></summary>
        <content type="html"><![CDATA[<p>node，npm，npx</p>
<!-- more -->
<p>（1）NPM（node package manager）是 node.js 的包管理和分发工具。它类似于PHP的Composer，Ruby的gem，Python的pip，Java的Maven……它可以让 javascript 开发者能够更加轻松的共享代码和共用代码片段，并且通过 npm 管理你分享的代码也很方便快捷和简单 。
npm 随node一并安装，但不是最新版，可以使用如下命令进行更新。
npm install npm@latest -g
查看配置信息
npm config list -l<br>
查看 npm 命令列表
$ npm help
$ npm install -h</p>
<p>（2）NPX 。
npx 想要解决的主要问题，就是调用项目内部安装的模块。
npx避免全局安装模块
$ npx create-react-app my-react-app    npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。</p>
<p>npx执行 GitHub 源码
npx 还可以执行 GitHub 上面的模块源码。</p>
<p>执行 Gist 代码
$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
执行仓库代码
$ npx github:piuccio/cowsay hello
注意，远程代码必须是一个模块，即必须包含package.json和入口脚本。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建前端脚手架（1）-实现原理]]></title>
        <id>https://abshawn.github.io/post/gou-jian-qian-duan-jiao-shou-jia-1-shi-xian-yuan-li</id>
        <link href="https://abshawn.github.io/post/gou-jian-qian-duan-jiao-shou-jia-1-shi-xian-yuan-li">
        </link>
        <updated>2019-07-04T10:12:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h3 id="前端脚手架是什么">前端脚手架是什么</h3>
<h3 id="前端脚手架的">前端脚手架的</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[构建前端脚手架-综述]]></title>
        <id>https://abshawn.github.io/post/gou-jian-qian-duan-jiao-shou-jia</id>
        <link href="https://abshawn.github.io/post/gou-jian-qian-duan-jiao-shou-jia">
        </link>
        <updated>2019-07-04T10:04:56.000Z</updated>
        <summary type="html"><![CDATA[<p>身为一名devops对于自动化的工具非常好奇，对于前端脚手架自然也不能放过研究的机会。
问题难点，作为前端小白对于前端的工具、脚手架的原理和开发工具知之甚少。这也是对自己的挑战。</p>
]]></summary>
        <content type="html"><![CDATA[<p>身为一名devops对于自动化的工具非常好奇，对于前端脚手架自然也不能放过研究的机会。
问题难点，作为前端小白对于前端的工具、脚手架的原理和开发工具知之甚少。这也是对自己的挑战。</p>
<!-- more -->
<p>拆分问题：
1、弄清楚 前端脚手架的原理；
2、开发脚手架的工具列表；
3、拆分一个脚手架案例；
4、编写一个属于自己的脚手架；
5、总结、思考前端脚手架的自动化方法和思路；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java8的写法]]></title>
        <id>https://abshawn.github.io/post/java8</id>
        <link href="https://abshawn.github.io/post/java8">
        </link>
        <updated>2019-06-06T08:08:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java8-的写法">java8 的写法</h1>
<h2 id="lambda表达式">lambda表达式</h2>
<pre><code>String[] atp = {&quot;Rafael Nadal&quot;, &quot;Novak Djokovic&quot;,
                &quot;Stanislas Wawrinka&quot;,
                &quot;David Ferrer&quot;,&quot;Roger Federer&quot;,
                &quot;Andy Murray&quot;,&quot;Tomas Berdych&quot;,
                &quot;Juan Martin Del Potro&quot;};
List&lt;String&gt; players =  Arrays.asList(atp);

// 以前的循环方式
for (String player : players) {
    System.out.print(player + &quot;; &quot;);
}

// 使用 lambda 表达式以及函数操作(functional operation)
//        参数 + 表达式
players.forEach((player) -&gt; System.out.print(player + &quot;; &quot;));
// 在 Java 8 中使用双冒号操作符(double colon operator)
players.forEach(System.out::println);
</code></pre>
<h2 id="循环">循环</h2>
<pre><code>  List&lt;RapServicecatalog&gt; rapServicecatalogList = rapServicecatalogMapper.selectByExample(rapServicecatalogExample);
        List&lt;TreeNode&gt; treeNodeList =   new ArrayList&lt;&gt; () ;

        rapServicecatalogList.forEach(servicecatalog  -&gt;{
            TreeNode temp=   new TreeNode();
            temp.setId(servicecatalog.getId());
            temp.setLabel(servicecatalog.getName());
            treeNodeList.add(temp);
        });
</code></pre>
<h2 id="泛型">泛型</h2>
<p>Java泛型中的标记符含义：</p>
<p>E - Element (在集合中使用，因为集合中存放的是元素)</p>
<p>T - Type（Java 类）</p>
<p>K - Key（键）</p>
<p>V - Value（值）</p>
<p>N - Number（数值类型）</p>
<p>？ -  表示不确定的java类型</p>
<p>S、U、V  - 2nd、3rd、4th types</p>
<p>Object跟这些标记符代表的java类型有啥区别呢？</p>
<p>Object是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p>
<h2 id="函数式编程">函数式编程</h2>
<h2 id="serializable序列化接口">Serializable序列化接口</h2>
<p>private static final long serialVersionUID = 1L;
作为一个标识，让jvm来帮助对类进行序列化；</p>
<p>序列化之后，可以进行传输和存储；
一般 entity 实体；和 vo 前端传给后端需要序列化；</p>
<p>技巧：可以在基础类，父类上implement serializable ；
子类就不需要重复实现啦；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[撰写博客的日志记录]]></title>
        <id>https://abshawn.github.io/post/log-record</id>
        <link href="https://abshawn.github.io/post/log-record">
        </link>
        <updated>2019-06-06T08:08:13.000Z</updated>
        <summary type="html"><![CDATA[<p>记录每次更新的功能和内容:</p>
<p>提供工作效率，每周备份一次，每周发版两次。
每周三、日：将撰写的文字，发布到github。
每周日：8点到9点，进行备份。</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录每次更新的功能和内容:</p>
<p>提供工作效率，每周备份一次，每周发版两次。
每周三、日：将撰写的文字，发布到github。
每周日：8点到9点，进行备份。</p>
<!-- more -->
<pre><code>	第6次

时间：2019-06-16 10:50
版本：v-1-1
功能：迁移hexo博客到g'ridea
内容：hexo文章挪到新平台后进行同步覆盖github page
	补充：hexo在实验楼的环境已经没有了
	
		第5次

时间：2019-06-16 18:16
版本：v-1-0
功能：迁移hexo博客到g'ridea
内容：hexo文章挪到新平台后进行同步覆盖github page
	补充：hexo在实验楼的环境已经没有了

第4次

时间：2016-07-17 18:16
版本：v-7-3
功能：撰写分类为linux入门的6篇文字
内容：linux入门
补充：

第3次

时间：2016-07-06 14:16
版本：v-7-2
功能：撰写分类为python的文章，撰写about页面
内容：
补充：

第2次

时间：2016-07-05 14:16
版本：v-7-1
功能：添加了分类、标签、搜索功能
内容：new post 格式的更新，补充log更新日志。
补充：进一步完善，about 个人简介。

第1次

时间：2016-06-30 14:16
版本：v-6-1
功能：搭建了该博客平台，撰写了3篇博文
内容：实验楼linux环境搭建，hexo的安装，github ssh验证。
补充：
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客从hexo切换到gridea]]></title>
        <id>https://abshawn.github.io/post/change-boke</id>
        <link href="https://abshawn.github.io/post/change-boke">
        </link>
        <updated>2019-06-06T07:46:22.000Z</updated>
        <summary type="html"><![CDATA[<p>博客从hexo切换到gridea，更容易编写。
👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。很适合用来记录我的技术成长之路。目前我也是用本地的markdown来管理自己的技术文档的。切换无成本。一次配置，一键发布共享。</p>
]]></summary>
        <content type="html"><![CDATA[<p>博客从hexo切换到gridea，更容易编写。
👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。很适合用来记录我的技术成长之路。目前我也是用本地的markdown来管理自己的技术文档的。切换无成本。一次配置，一键发布共享。</p>
<!-- more -->
<p>1、hexo 之前是在github上弄的网络环境，便于随时随地撰写并通过命令行发布到github page上，但同时带来了一些额外的写作的成本。</p>
<p>2、发现gridea后，全平台兼容，能很好的支持mac端写作，并且一次配置之后，就可以很方便的撰写并发布到github page上啦。与简书的写作方式类似，无切换成本。</p>
<p>3、界面化的写作模式，更符合人性的特点，更容易促使日更。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux入门之任务计划crontab(5)]]></title>
        <id>https://abshawn.github.io/post/hexo-on-boke-linux-easy-5</id>
        <link href="https://abshawn.github.io/post/hexo-on-boke-linux-easy-5">
        </link>
        <updated>2016-07-17T03:13:17.000Z</updated>
        <summary type="html"><![CDATA[<p>crontab介绍</p>
<p>我们时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本文同你一起掀开Linux系统自动任务的神秘面纱。</p>
]]></summary>
        <content type="html"><![CDATA[<p>crontab介绍</p>
<p>我们时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本文同你一起掀开Linux系统自动任务的神秘面纱。</p>
 <!-- more --> 
<p>1、基本概念</p>
<p>crontab自动任务的理解
用于设置周期性被执行的指令
该命令读取指令存放于crontab文件中供后续读取和执行
crond为其守护进程，一般在后台默默运行，不间断的检查是否有预定的作业需要执行。
crontab命令的格式和参数
分 时 日 月 星期 &lt;命令&gt; &lt;日志&gt;
crontab格式和参数.png
2、环境的准备</p>
<p>实验楼的linux系统，默认是没有启动日志和cron守护进程，需要手动启动</p>
<p>启动日志的命令</p>
<p>service rsyslog start （已启动的可以不起）
1</p>
<p>启动crontab</p>
<p>sudo cron -f &amp;
1
2
3
4
5
6
7
8
9
10
11
12
13
14</p>
<pre><code>&gt; * 操作截图如下
![启动日志和crontab](https://dn-simplecloud.qbox.me/1790261468638161237-wm)


&gt; ** crontab 新增任务**
&gt; * 使用vi编辑器进行编辑，输入i切到编辑模式
-  ```- crontab -e 
</code></pre>
<p><img src="https://dn-simplecloud.qbox.me/1790261468638619229-wm" alt="新增任务计划"></p>
<blockquote>
<ul>
<li>查看结果</li>
</ul>
</blockquote>
<ul>
<li>没有生成文件？日志报错“no mta installed discarding output”</li>
</ul>
<pre><code class="language-sudo">报错日志

查找原因，发现 书写格式有误 ，需在date之后加个空格。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
*/1 * * * * touch /home/shiyanlou/$(date  +\%Y\%m\%d\%H\%M\%S) 
</code></pre>
<p><img src="https://dn-simplecloud.qbox.me/1790261468650326234-wm" alt="已生成20160716142101文件"></p>
<hr>
<h2 id="crontab使用"><strong>crontab使用</strong></h2>
<p>一个是linux系统，是存在多个用户的，那么每个用户建立的crontab是否会有冲突呢？<strong>当然不会冲突</strong>，要是冲突，就没有安全性和可靠性而言了。那么具体是怎么做到的呢？</p>
<h3 id="1-配置文件的独立性">1、配置文件的独立性</h3>
<blockquote>
<ul>
<li>不同用户，在/var/spool/cron/crontabs里存在一个对应的配置文件</li>
</ul>
</blockquote>
<ul>
<li>保证了 隔离、独立、有效</li>
<li>如下图，存在 root和shiyanlou 两个用户的crontab
<img src="https://dn-simplecloud.qbox.me/1790261468650781682-wm" alt="crontab独立性"></li>
</ul>
<h3 id="2-守护进程cron自动执行">2、守护进程cron自动执行</h3>
<blockquote>
<ul>
<li>在etc目录下存在如下cron文件，这几个文件会让你的任务计划安装计划正确执行</li>
</ul>
</blockquote>
<ul>
<li>1、 /etc/cron.daily，目录下的脚本会每天让执行一次，在每天的6点25分时运行；</li>
<li>2、 /etc/cron.hourly，目录下的脚本会每个小时让执行一次，在每小时的17分钟时运行；</li>
<li>3、/etc/cron.mouthly，目录下的脚本会每月让执行一次，在每月1号的6点52分时运行；</li>
<li>4、 /etc/cron.weekly，目录下的脚本会每周让执行一次，在每周第七天的6点47分时运行；</li>
<li>如下图所示
<img src="https://dn-simplecloud.qbox.me/1790261468651152728-wm" alt="etc下cron文件"></li>
</ul>
<hr>
<h2 id="crontab进阶"><strong>crontab进阶</strong></h2>
<p>设定crontab之后，系统管理员最关心的是crontab任务有没有按照计划执行完毕，执行过程中有没有出错？那么我们可以通过查看日志文件来了解请情况。</p>
<h3 id="1-crontab系统日志">1、crontab系统日志</h3>
<blockquote>
<ul>
<li>默认的系统日志  存在于  /var/log/syslog 文件里</li>
<li>自定义启用cron日志  通过编辑 /etc/rsyslog.d/50-default.conf配置文件，达到启用cron.log专用日志，详见下图
<img src="https://dn-simplecloud.qbox.me/1790261468651337661-wm" alt="系统日志"></li>
</ul>
</blockquote>
<h3 id="2-crontab执行日志">2、crontab执行日志</h3>
<blockquote>
<ul>
<li>在crontab命令里，可以自定义执行日志的路径和名称【分 时 日 月 星期 &lt;执行的命令&gt; &lt;执行的日志&gt;】，如下两个实例：</li>
</ul>
</blockquote>
<pre><code class="language-python">（1） * 8 * * 0  /home/shiyanlou/mybin/back.sh 1&gt;&gt;/home/shiyanlou/back.log 2&gt;&gt;/home/shiyanlou/back.log
 （2） * 8 * * 0 /home/shiyanlou/mybin/back.sh &gt;&gt;/home/shiyanlou/back.log 2&gt;&amp;1
（1）和（2）是两种不同的写法，但是含义是一样的
其中，“2&gt;&amp;1” 表示 2跟1使用同一个日志文件
其中， 1 表示执行的标准日志输出 ；2表示 执行异常的日志输出

作业

撰写一个crontab任务计划，使其完成在“每周日的上午8点自动执行一次备份脚本 back.sh”

back.sh 是对该目录/home/shiyanlou/Code下的blog目录文件进行压缩打包；
结合上面设定的crontab自动任务，现补充 back.sh的脚本如下：</code></pre>
]]></content>
    </entry>
</feed>